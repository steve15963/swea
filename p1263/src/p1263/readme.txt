그룹 1 싸이클이 없고 N <= 10 인 경우
 > 인접리스트와 인접행렬의 차이가 없음.
그룹 2 싸이클이 없고 10 < N <= 100 인경우
 > 인접리스트와 인접행렬의 차이가 없음.
그룹 3 싸이클이 있고 N<= 10
 > 인접리스트와 인접행렬의 차이가 없음.
그룹 4 싸이클이 있고10 < N <= 100
 > 인접리스트와 인접행렬의 차이가 없음.
그룹 5 모든 경우가 존재하고 100 < N <= 1000
 > 인접행렬대신 인접리스트 사용시 유효한 성능향상이 있을거 같지만.
 	모든 경우의 수가 존재하므로 완전그래프라는 의미이므로.
 	리스트와 행렬의 성능 차이가 거의 느낄 수 없으므로
 	
 인접행렬을 사용하기로 하였습니다.
 
 
 입력은
 네트워크의 인접 행렬이 행 우선 (row-by-row) 순으로
 N * N 행렬을 만들어야하고
 
 이 행렬테이블을 플로이드 워샬의 DP테이블로 쓰기로 하였고.
 
 이를 
if(start == end || k == end) continue;
if(distance[start][end] > distance[start][k] + distance[k][end]){
	distance[start][end] = distance[start][k] + distance[k][end];
}
와 같이 코딩하였고
Print라는 메소드를 별도로 작성하여
모든 인접행렬의 열에서 합이 가장 작은 열을 찾아 출력하였습니다.